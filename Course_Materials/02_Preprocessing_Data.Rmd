---
title: "RNA-seq analysis in R"
author: "Stephane Ballereau, Mark Dunning, Oscar Rueda, Ashley Sawle"
date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output:
  html_notebook:
    toc: yes
  html_document:
    toc: yes
minutes: 300
layout: page
subtitle: Pre-processsing RNA-seq data
bibliography: ref.bib
editor_options: 
  chunk_output_type: console
---

```{r knitrOpts, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

In this section we will begin the process of analysing the RNAseq in R. In the
next section we will use DESeq2 [@Love2014] for differential analysis. Before we
do that we need to:

* import our counts into R
* manipulate the imported data so that it is in the correct format for DESeq2
* filter out unwanted genes
* run some initial QC on the raw count data

# Data import

First, let's load all the packages we will need to analyse the data.

```{r setup, message = FALSE}
library(tidyverse)
library(DESeq2)
library(ggfortify)
```

## Mouse mammary gland dataset

The data for this tutorial comes from a Nature Cell Biology paper,
[*EGF-mediated induction of Mcl-1 at the switch to lactation is essential for
alveolar cell survival*](http://www.ncbi.nlm.nih.gov/pubmed/25730472)
[@Fu2015]. The raw data (sequence reads) can be downloaded from SRA under
[SRP045534](https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?study=SRP045534),
and processed data (counts) can be downloaded from Gene Expression Omnibus 
database (GEO) under accession number
[GSE60450](http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE60450). Please
see [Supplementary 
material](../Supplementary_Materials/S1_Getting_raw_reads_from_SRA.html) for 
instructions on downloading raw files from SRA and aligning fastq using HISAT2.

This study examines the expression profiles of basal stem-cell enriched cells
(B) and committed luminal cells (L) in the mammary gland of virgin, pregnant
and lactating mice. Six groups are present, with one for each combination of
cell type and mouse status. Each group contains two biological replicates.

# Reading in the sample metadata

The `sampleinfo` file contains basic information about the samples that we will
need for the analysis today.

```{r loadSampleInfo}
# Read the sample information into a data frame
sampleinfo <- read_tsv("data/SampleInfo.txt")
sampleinfo
```

## Reading in the  count data

The raw reads were aligned using HISAT2 [@Kim2015] to the GRCm38 mouse reference
genome from Ensembl. featureCounts [@Liao2014] was used to count reads against
the Ensembl gene annotation and generate a counts matrix (as described in 
(Section 1)[01_Counting.html].

First we need to read the data into R from the file in the *data* directory.

```{r loadData}
# Read the data into R
seqdata <- read_tsv("data/GSE60450_Lactation.featureCounts", comment = "#")
seqdata
```

In the `seqdata` object each row represents a gene. The columns contains:

1. *Geneid* - Ensembl ID
2-5 *Chr*, *Start*, *End*, *Strand* - Genomic locations of each exon of the gene
6 *Length* - Transcript length of the gene
7-18 Once Column for each sample with the count of how many reads were assigned
to each gene by featureCounts.

## Format the data

We will be manipulating and reformating the counts matrix into a suitable
format for DESeq2.

The `seqdata` is a `tibble` (a kind of `dataframe`) in which the first six 
columns contain annotation information and the remaining columns contain the 
count data.

DESeq2 requires a simple object containing only the count data and with some
form of gene ID as the row names.

Let's create new counts data object, `countdata`, that contains only the
counts for the 12 samples.  

Our `sampleinfo` object contains a column with the sample names. We should
adjust the column names of our matrix to match them - we just need to remove
the `.bam` suffix. 

It is also *critical* to ensure that the samples in the columns are in the same
order as the rows of `sampleinfo`. When we load these objects into DESeq2 for 
the analysis it will not guess which row of the `sampleinfo` belongs to which
column of the counts matrix, it will assume the same order.

```{r createCountMatrix}
# tibbles aren't allowed rownames so first we need to convert to a dataframe
countdata <- as.data.frame(seqdata) %>% 
    column_to_rownames("Geneid") %>% # turn the geneid column into rownames
    rename_all(str_remove, ".bam") %>% # remove the ".bam" from the column names
    select(sampleinfo$Sample) # keep sample columns using sampleinfo
```

Here, we used `str_remove` to remove the unwanted suffix from the column names.
The `stringr` package has a lots of useful functions for manipulating strings 
(text), e.g. `str_replace` or `str_extract`.


# Filtering the genes

For many analysis methods it is advisable to filter out as many genes as 
possible prior to starting the analysis in order to decrease the impact on fasle
discovery rates when applying multiple testing correction. This is normally done
by filtering out genes with low numbers of reads, which are likely to be 
uninformative.

With `DESeq` this is not necessary as it applies a process it calls `independent
filtering` during the analysis process. On the other hand, some filtering for 
genes that are very lowly expressed does reduce the size of the data matrix, 
meaning that less memory is required and processing steps are carried out 
faster.

We will keep all genes where the total number of reads across all samples is 
greater than 5.

```{r filterGenes}
dim(countdata)
keep <- rowSums(countdata) > 5
countdata <- countdata[keep,]
dim(countdata)
```

# Quality assessment

Before moving on to doing the actually differential expression analysis it 
important do assess the quality of our data.

## Library sizes and distribution plots

First, we can plot how many reads we have for each sample in the `ddsObj`. 
Whilst normalisation can account for imbalance in coverage across the samples,
extreme differences may be indicative of underlying problems in the samples.

```{r ddsLibrarySizes}
countdata %>% 
    summarise_all(sum) %>% 
    gather("Sample", "Counts") %>% 
    ggplot(aes(x=Sample, y=Counts)) +
    geom_bar(stat="identity", col="black", fill="steelblue")
```

Count data is not normally distributed, so if we want to examine the
distributions of the raw counts it is helpful to transform the data on to a log
scale. DESeq2 provides two commands that can be used to this, here we will use
the command `rlog`, you can read about it companion `vst` and the comparison
between the two 
[here](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#count-data-transformations). 

We'll check the distribution of read counts using a boxplot and well add some
colour to see if there is any difference between sample groups

```{r plotLogCounts}
# Get log2 counts per million
logcounts <- rlog(as.matrix(countdata))
# Check distributions of samples using boxplots
# Add a horizontal line at the overall median 
logcounts %>% 
    as.data.frame() %>% 
    gather("Sample", "logCounts") %>% 
    left_join(sampleinfo, "Sample") %>% 
    ggplot(aes(x=Sample, y=logCounts, fill=Status)) +
        geom_hline(yintercept = median(logcounts), colour = "blue", size=2) +
        geom_boxplot()
        


```

From the boxplots we see that overall the density distributions of raw
log-intensities are not identical but still not very different. If a sample is
really far above or below the blue horizontal line we may need to investigate
that sample further.

## Principle Component Analysis



## Multidimensional scaling plots

By far, one of the most important plots we make when we analyse RNA-Seq data
are MDSplots. An MDSplot is a visualisation of a principle components analysis,
which determines the greatest sources of variation in the data. A principle
components analysis is an example of an unsupervised analysis, where we don't
need to specify the groups. If your experiment is well controlled and has
worked well, what we hope to see is that the greatest sources of variation in
the data are the treatments/groups we are interested in. It is also an
incredibly useful tool for quality control and checking for outliers. We can
use the `plotMDS` function to create the MDS plot.

```{r plotMDSbasic}
plotMDS(ddsObj)
```

It is a bit difficult to see exactly what is going on with the default plot,
although we do see samples grouping together in pairs. To make this plot more
informative, we can colour the samples according to the grouping information.
We can also change the labels, or instead of labels we can have points.

```{r setPlotParams}
# Let's set up colour schemes for CellType
# How many cell types and in what order are they stored?
levels(sampleinfo$CellType)
# Let's choose purple for basal and orange for luminal
col.cell <- c("purple","orange")[sampleinfo$CellType]
data.frame(sampleinfo$CellType, col.cell)
col.cell
sampleinfo$CellType

# Similarly for status
levels(sampleinfo$Status)
col.status <- c("blue","red","dark green")[sampleinfo$Status]
col.status
```

```{r plotMDScolored, fig.height=5, fig.width=10}
# We specify the option to let us plot two plots side-by-sde
par(mfrow=c(1,2))

# Redo the MDS with cell type colouring
plotMDS(ddsObj, col=col.cell, main="Cell type")

# Let's add a legend to the plot so we know which colours correspond to which
# cell type
legend("topleft",
       fill=c("purple","orange"), 
       legend=levels(sampleinfo$CellType))

plotMDS(ddsObj,col=col.status, main="Status")
legend("topleft",
       fill=c("blue","red","dark green"), 
       legend=levels(sampleinfo$Status))
```

> ### Discussion
>
> Look at the MDS plot coloured by cell type.
> Is there something strange going on with the samples?
> Identify the two samples that don't appear to be in the right place.
>

```{r correctSampleSheet}
# There is a corrected sample info file in your data directory
# I'm going to write over the sampleinfo object with the corrected sample info
sampleinfo <- read.delim("data/SampleInfo_Corrected.txt")
sampleinfo
```

```{r plotMDSfixed, fig.height=5, fig.width=10}
# Redo the MDSplot with corrected information
par(mfrow=c(1,2))
col.cell <- c("purple","orange")[sampleinfo$CellType]
col.status <- c("blue","red","dark green")[sampleinfo$Status]

plotMDS(ddsObj,col=col.cell, main="Cell type")
legend("topleft",fill=c("purple","orange"),legend=levels(sampleinfo$CellType))

plotMDS(ddsObj,col=col.status, main="Status")
legend("topleft",fill=c("blue","red","dark green"),legend=levels(sampleinfo$Status))
```

> ### Discussion
>
> What is the greatest source of variation in the data (i.e. what does dimension 1 represent)?
> What is the second greatest source of variation in the data?
>

> ### Challenge 2
> Rather than plotting the sample name we could use a symbol using the `pch` 
> argument. If we use a different symbol for each of the cell types we could
> have a single plot with both the cell type and status information represented.
> 
> 1. Redo the plots choosing your own colours.
> 2. Change the plotting character to a symbol instead of the column names  
> HINT: use `pch` (**p**lotting **ch**aracters) argument. Try `pch=16` and see what happens.
> 3. Change the plotting characters such that basal samples have the value `24` and luminal samples have the value `25` and colour the points by status (lactate, pregnant, virgin)
>

**Solution**
```{r solutionChallenge2, echo=FALSE}




```


The distance between each pair of samples in the MDS plot is calculated as the
leading fold change, defined as the root-mean-square of the largest 500
log2-fold changes between that pair of samples. Replicate samples from the same
group cluster together in the plot, while samples from different groups form
separate clusters. This indicates that the differences between groups are
larger than those within groups, i.e., differential expression is greater than
the variance and can be detected. In the MDS plot, the distance between basal
samples on the left and luminal cells on the right is about 6 units,
corresponding to a leading fold change of about 64-fold (2^6 = 64) between
basal and luminal. The expression differences between virgin, pregnant and
lactating are greater for luminal cells than for basal.

Notes

* The MDS plot can be simply generated with `plotMDS(ddsObj)`. The additional
code is purely for aesthetics, to improve the visualization of the groups.
* Clustering in the MDS plot can be used to motivate changes to the design
 matrix in light of potential batch effects. For example, imagine that the
 first replicate of each group was prepared at a separate time from the second
 replicate. If the MDS plot showed separation of samples by time, it might be
 worthwhile including time in the down stream analysis to account for the
 time-based effect.

### Additional - MDS beyond the first two dimensions

`plotMDS` plots the first two dimensions as a default, however you can plot higher dimensions using the `dim` argument.

```{r plotMDS3and4, fig.width=5, fig.height=5}
# Dimension 3 appears to separate pregnant samples from the rest. Dim4?
plotMDS(ddsObj,dim=c(3,4), col=col.status)
legend("topleft",fill=c("blue","red","dark green"),legend=levels(sampleinfo$Status))
```

### Additional - Interactive MDS Plot with Glimma [optional]

Another alternative is to generate an interactive MDS plot using the *Glimma*
package. This allows the user to interactively explore the different
dimensions.

```{r glimmaMDS}
labels <- paste(sampleinfo$SampleName, sampleinfo$Group)
glMDSPlot(ddsObj, labels=labels, groups=sampleinfo$Group, folder="mds")
```

*Glimma* was created to make interactive versions of some of the popular plots
from the *limma* package. At present it can be used to obtain MDS plots and
mean-difference (MD) plots, which will be covered later. The output of
`glMDSPlot` is an html page (/mds/MDS-Plot.html) that shows the MDS plot on the
left, and the amount of variation explained by each dimension in a barplot on
the right. The user can hover over points to find out sample information, and
switch between successive dimensions in the MDS plot by clicking on the bars in
the barplot. The default MDS plots shows dimensions 1 and 2.

## Hierarchical clustering with heatmaps

An alternative to `plotMDS` for examining relationships between samples is
using hierarchical clustering. Heatmaps are a nice visualisation to examine
hierarchical clustering of your samples. We can do this using the `heatmap.2`
function from the *gplots* package. In this example `heatmap.2` calculates a
matrix of euclidean distances from the logCPM (`logcounts` object) for the 500
most variable genes. (Note this has more complicated code than plotting
principle components using `plotMDS`.)

The *RColorBrewer* package has nicer colour schemes, accessed using the
`brewer.pal` function. "RdYlBu" is a common choice, and "Spectral" is also
nice.

Note:The `png` function will create a png file to save the plots created
straight after, and will close this file when `dev.off()` is called. To see
your plots interactively, simply omit those two lines.

Let's select data for the 500 most variable genes and plot the heatmap

```{r getHMData}
# We estimate the variance for each row in the logcounts matrix
var_genes <- apply(logcounts, 1, var)
head(var_genes)
# Get the gene names for the top 500 most variable genes
select_var <- names(sort(var_genes, decreasing=TRUE))[1:500]
head(select_var)
# Subset logcounts matrix
highly_variable_lcpm <- logcounts[select_var,]
dim(highly_variable_lcpm)
head(highly_variable_lcpm)
```

```{r plotHM, fig.width=10, fig.height=10}
# Get some nicer colours
mypalette <- brewer.pal(11, "RdYlBu")
# http://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3
morecols <- colorRampPalette(mypalette)
# Set up colour vector for celltype variable
col.cell <- c("purple","orange")[sampleinfo$CellType]

# Plot the heatmap
heatmap.2(highly_variable_lcpm, 
          col=rev(morecols(50)),
          trace="column", 
          main="Top 500 most variable genes across samples",
          ColSideColors=col.cell,scale="row")
```

> ### Additional Challenge 3
>
> Redo the heatmap using the top 500 LEAST variable genes.  
> Change the colour scheme to "PiYG" and redo the heatmap. Try `?RColorBrewer` and see what other colour schemes are available.  
> Change the sample names to `group` using the `labCol` argument  
> Remove the gene names from the righthand side of the plot using `labRow`  

**Solution**
```{r solutionChallenge3, echo=FALSE, fig.height=8, fig.width=6}




```


-----
# Convert counts to **DESeqDataSet** object

Next we'll create a `DESeqDataSet` object. This is an object used by `DESeq2` to
store count data. It has a number of slots for storing count data, sample 
information, the model design for the differential expression analysis, and
various other parameters about the data.

In the simplest form we need to provide counts, sample information and a design
formula. For now we just want to perform some QC so we will provide a simple 
model where would just be concerned with contrasting the differential expression
between cell types. We can change the model later if we want to.

```{r makeDDSObj}
# first lets check that our rows and columns match
all(sampleinfo$Sample == colnames(countdata))
# create the design formula
design <- as.formula(~ CellType)
# create the DESeqDataSet object
ddsObj <- DESeqDataSetFromMatrix(countData = countdata,
                              colData = sampleinfo,
                              design = design)
```

# Normalisation for composition bias

The trimmed mean of M-values normalization method (TMM) is performed to
eliminate composition biases between libraries [@robinson2010tmm]. This
generates a set of normalization factors, where the product of these factors
and the library sizes defines the effective library size. The `calcNormFactors`
function in `eddsR` calculates the normalization factors between libraries. TMM
normalisation (and most scaling normalisation methods) scale relative to one
sample.

```{r calcNormFactors}
# Apply normalisation to ddsList object
ddsObj <- calcNormFactors(ddsObj)
```

This will update the normalisation factors in the `ddsList` object (their
default values are 1). Take a look at the normalisation factors for these
samples.

```{r vizNormFactors}
ddsObj$samples
```

The normalization factors multiply to unity across all libraries. A
normalization factor below one indicates that the library size will be scaled
down, as there is more suppression (i.e., composition bias) in that library
relative to the other libraries. This is also equivalent to scaling the counts
upwards in that sample. Conversely, a factor above one scales up the library
size and is equivalent to downscaling the counts.


The last two samples have much smaller normalisation factors, and MCL1.LA and
MCL1.LB have the largest. If we plot mean difference plots using the `plotMD`
function for these samples, we should be able to see the composition bias
problem. We will use the `logcounts`, which have been normalised for library
size, but not for composition bias.

```{r plotRawMD, fig.height=5, fig.width=10}
par(mfrow=c(1,2))
plotMD(logcounts, column = 7)
abline(h=0,col="grey")
plotMD(logcounts, column = 11)
abline(h=0,col="grey")
```

The mean-difference plots show average expression (mean: x-axis) against
log-fold-changes (difference: y-axis).  Because our `ddsList` object contains
the normalisation factors, if we redo these plots using `ddsObj`, we should see
the composition bias problem has been solved.

```{r plotNormedMD, fig.height=5, fig.width=10}
par(mfrow=c(1,2))
plotMD(ddsObj,column = 7)
abline(h=0,col="grey")
plotMD(ddsObj,column = 11)
abline(h=0,col="grey")
```

> ## Challenge 4
>
> Plot the biased and unbiased MD plots side by side for the same sample to see the before and after TMM normalisation effect.
>

**Solution**
```{r solutionChallenge4, echo=FALSE, fig.height=5, fig.width=10}




```

**We need to save a few data objects to use for Day 2 so we don't have to rerun everything**

```{r saveData}
save(ddsObj, sampleinfo, file="Robjects/preprocessing.Rdata")
```
